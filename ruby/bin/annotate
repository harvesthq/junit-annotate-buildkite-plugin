#!/usr/bin/env ruby

require 'rexml/document'
require 'rexml/element'
require 'cgi/util'

# Reads a list of junit files and returns a nice Buildkite build annotation on
# STDOUT that summarizes any failures.

junits_dir = ARGV[0]
abort("Usage: annotate <junits-dir>") unless junits_dir
abort("#{junits_dir} does not exist") unless Dir.exist?(junits_dir)

def text_content(element)
  # Handle mulptiple CDATA/text children elements
  text = element.texts().map(&:value).join.strip
  if text.empty?
    nil
  else
    text
  end
end

def message_content(element)
  # Handle empty attributes
  message = element.attributes['message'];
  if message.nil? || message.empty?
    nil
  else
    message.to_s
  end
end

class Failure < Struct.new(:body, :message, :type, :file, :name, :suite_name)
  def self.from(element, testcase, testsuite)
    new(
      text_content(element),
      message_content(element),
      element.attributes['type'],
      testcase.attributes['file'],
      testcase.attributes['name'],
      testsuite.attributes['name']
    )
  end
end

junit_report_files = Dir.glob(File.join(junits_dir, "**", "*"))
stats = { skipped: 0, failures: 0, tests: 0, assertions: 0, time: 0.0 }
failures = []

junit_report_files.sort.each do |file|
  next if File.directory?(file)

  STDERR.puts "Parsing #{file.sub(junits_dir, '')}"
  xml = File.read(file)
  doc = REXML::Document.new(xml)

  REXML::XPath.each(doc, '//testsuite') do |testsuite|
    stats[:assertions] += testsuite.attributes['assertions'].to_i
    stats[:failures]   += testsuite.attributes['failures'].to_i
    stats[:skipped]    += testsuite.attributes['skipped'].to_i
    stats[:tests]      += testsuite.attributes['tests'].to_i
    stats[:time]       += testsuite.attributes['time'].to_f

    testsuite.elements.each("testcase") do |testcase|
      testcase.elements.each("failure") do |element|
        failures << Failure.from(element, testcase, testsuite)
      end
      testcase.elements.each("error") do |element|
        failures << Failure.from(element, testcase, testsuite)
      end
    end
  end
end

STDERR.puts "--- ❓ Checking failures"
STDERR.puts "Ran **#{stats[:tests]}** tests in **#{stats[:time].round(2)}s**."

if failures.empty?
  STDERR.puts "There were no failures/errors 🙌"
  exit 0
else
  STDERR.puts "There #{failures.length == 1 ? "is **1*8 failure/error" : "are **#{failures.length}** failures/errors" } 😭"
end

STDERR.puts "--- ✍️ Preparing annotation"

puts "Ran **#{stats[:tests]}** tests in **#{stats[:time].round(2)}s**."
failures.each do |failure|
  puts "<details>"
  puts "<summary><code>#{failure.suite_name}##{failure.name}</code></summary>\n\n"
  if failure.body
    puts "<pre class=\"term\"><code>#{CGI.escapeHTML(failure.message.chomp.strip)}\n\n#{CGI.escapeHTML(failure.body.chomp.strip)}</code></pre>\n\n"
  end
  puts "</details>"
  puts "" unless failure == failures.last
end
